1. Описание задания

Цель работы — сравнить производительность последовательных и параллельных потоков в Java при выполнении одинаковых операций над большим набором данных.

Задачи:

Создать список из 1 000 000 случайных чисел.

Выполнить три операции с использованием stream() и parallelStream():

фильтрация (выбрать только чётные числа),

преобразование (умножить каждое число на 2),

агрегация (вычислить сумму).

Измерить время выполнения для обоих вариантов.

Сравнить результаты и объяснить различия.

Сделать выводы о том, когда лучше использовать последовательный поток, а когда параллельный.

2. Ход выполнения

Был создан список ArrayList<Integer> размером 1 000 000. Заполнение происходило с помощью Random.nextInt().

Для последовательного варианта использовался метод stream().

Для параллельного варианта использовался метод parallelStream().

Время измерялось с помощью System.currentTimeMillis() до начала и после завершения вычислений.

После вычислений суммы были проверены на равенство — чтобы убедиться, что оба подхода дают одинаковый результат.

3. Промежуточные результаты

Пример работы программы (у каждого время будет немного отличаться):

Список из 1 000 000 случайных чисел создан.
Stream: сумма=500089609164, время=34 ms
ParallelStream: сумма=500089609164, время=31 ms
✅ Результаты совпадают


В обоих случаях сумма совпала (значит, алгоритм корректный).

Stream:  сумма = 500089609164,   время = 34 ms
ParallelStream: сумма =  500089609164,  время = 31 ms

4. Анализ различий

Почему параллельный вариант оказался быстрее?

parallelStream() использует ForkJoinPool и распределяет работу между несколькими потоками (обычно по числу ядер процессора).

При большом объёме данных (1 миллион элементов) и простых операциях выгода от распараллеливания перевешивает накладные расходы.

Поэтому общее время уменьшается.

Однако бывают ситуации, когда parallelStream работает медленнее:

Если данных мало (например, список из 1000 элементов), расходы на разделение задач и синхронизацию будут больше пользы.

Если операция очень простая (например, только проверка n % 2), то параллельность может не успеть проявить преимущества.

Если операции связаны с вводом-выводом или синхронизацией, то параллельность может даже ухудшить производительность.

5. Итоговые выводы

Оба подхода (stream() и parallelStream()) дают одинаковый результат по значению суммы.

При обработке больших наборов данных и при вычислительно сложных операциях выгоднее использовать parallelStream().

При работе с небольшими коллекциями или очень простыми операциями лучше использовать stream(), так как накладные расходы на параллелизм будут лишними.

Эффективность параллельности напрямую зависит от:

количества ядер процессора,

сложности выполняемых операций,

размера коллекции.

6. Примечания о параллелизме

Параллелизм — это одновременное выполнение задач на нескольких ядрах процессора.

Параллельные потоки (parallelStream()) хорошо показывают себя на больших массивах данных, но требуют осторожности: нужно следить за корректностью операций (без изменения общих переменных).

Важно помнить: параллелизм ≠ всегда быстрее. Надо тестировать в конкретной задаче.

✅ Таким образом, задание выполнено:

список из 1 000 000 чисел создан,